//
// auto-generated by op2.py
//

//global constants
#ifndef MAX_CONST_SIZE
#define MAX_CONST_SIZE 128
#endif

__constant__ double m_e_cut_cuda;
__constant__ double m_p_cut_cuda;
__constant__ double m_q_cut_cuda;
__constant__ double m_v_cut_cuda;
__constant__ double m_u_cut_cuda;
__constant__ double m_hgcoef_cuda;
__constant__ double m_ss4o3_cuda;
__constant__ double m_qstop_cuda;
__constant__ double m_monoq_max_slope_cuda;
__constant__ double m_monoq_limiter_mult_cuda;
__constant__ double m_qlc_monoq_cuda;
__constant__ double m_qqc_monoq_cuda;
__constant__ double m_qqc_cuda;
__constant__ double m_eosvmax_cuda;
__constant__ double m_eosvmin_cuda;
__constant__ double m_pmin_cuda;
__constant__ double m_emin_cuda;
__constant__ double m_dvovmax_cuda;
__constant__ double m_refdens_cuda;
__constant__ double m_qqc2_cuda;
__constant__ double m_ptiny_cuda;
__constant__ double m_gamma_t_cuda[32];
__constant__ double m_twelfth_cuda;
__constant__ double m_sixth_cuda;
__constant__ double m_c1s_cuda;
__constant__ double m_ssc_thresh_cuda;
__constant__ double m_ssc_low_cuda;

//header
#include "op_lib_cpp.h"
#include "op_cuda_rt_support.h"
#include "op_cuda_reduction.h"

void op_decl_const_char(int dim, char const *type,
int size, char *dat, char const *name){
  if (!OP_hybrid_gpu) return;
  if (!strcmp(name,"m_e_cut")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_e_cut_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_p_cut")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_p_cut_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_q_cut")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_q_cut_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_v_cut")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_v_cut_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_u_cut")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_u_cut_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_hgcoef")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_hgcoef_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_ss4o3")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_ss4o3_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_qstop")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_qstop_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_monoq_max_slope")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_monoq_max_slope_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_monoq_limiter_mult")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_monoq_limiter_mult_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_qlc_monoq")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_qlc_monoq_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_qqc_monoq")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_qqc_monoq_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_qqc")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_qqc_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_eosvmax")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_eosvmax_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_eosvmin")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_eosvmin_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_pmin")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_pmin_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_emin")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_emin_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_dvovmax")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_dvovmax_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_refdens")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_refdens_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_qqc2")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_qqc2_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_ptiny")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_ptiny_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_gamma_t")) {
    if (!strcmp(name,"m_gamma_t") && size>MAX_CONST_SIZE) {
      printf("error: MAX_CONST_SIZE not big enough\n"); exit(1);
    }
    cutilSafeCall(cudaMemcpyToSymbol(m_gamma_t_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_twelfth")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_twelfth_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_sixth")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_sixth_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_c1s")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_c1s_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_ssc_thresh")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_ssc_thresh_cuda, dat, dim*size));
  }
  else
  if (!strcmp(name,"m_ssc_low")) {
    cutilSafeCall(cudaMemcpyToSymbol(m_ssc_low_cuda, dat, dim*size));
  }
  else
  {
    printf("error: unknown const name\n"); exit(1);
  }
}

//user kernel files
#include "initStressTerms_kernel.cu"
#include "IntegrateStressForElemsLoop_kernel.cu"
#include "FBHourglassForceForElems_kernel.cu"
#include "CalcVolumeDerivatives_kernel.cu"
#include "CheckForNegativeElementVolume_kernel.cu"
#include "setForceToZero_kernel.cu"
#include "CalcAccelForNodes_kernel.cu"
#include "BoundaryX_kernel.cu"
#include "BoundaryY_kernel.cu"
#include "BoundaryZ_kernel.cu"
#include "CalcVeloForNodes_kernel.cu"
#include "CalcPosForNodes_kernel.cu"
#include "CalcKinematicsForElem_kernel.cu"
#include "CalcLagrangeElemRemaining_kernel.cu"
#include "CalcMonotonicQGradientsForElem_kernel.cu"
#include "CalcMonotonicQRegionForElem_kernel.cu"
#include "NoExcessiveArtificialViscosity_kernel.cu"
#include "CalcHalfStepBVC_kernel.cu"
#include "CalcPHalfstep_kernel.cu"
#include "CalcBVC_kernel.cu"
#include "CalcPNew_kernel.cu"
#include "CalcNewE_kernel.cu"
#include "CalcNewEStep2_kernel.cu"
#include "CalcNewEStep3_kernel.cu"
#include "CalcNewEStep4_kernel.cu"
#include "CalcQNew_kernel.cu"
#include "CalcSoundSpeedForElem_kernel.cu"
#include "CopyEOSValsIntoArray_kernel.cu"
#include "CalcHalfSteps_kernel.cu"
#include "CheckEOSLowerBound_kernel.cu"
#include "CheckEOSUpperBound_kernel.cu"
#include "CalcEOSWork_kernel.cu"
#include "CopyTempEOSVarsBack_kernel.cu"
#include "CopyVelocityToTempArray_kernel.cu"
#include "ApplyLowerBoundToVelocity_kernel.cu"
#include "ApplyUpperBoundToVelocity_kernel.cu"
#include "ALE3DRelevantCheck_kernel.cu"
#include "updateVolumesForElem_kernel.cu"
#include "CalcCourantConstraint_kernel.cu"
#include "CalcHydroConstraint_kernel.cu"
