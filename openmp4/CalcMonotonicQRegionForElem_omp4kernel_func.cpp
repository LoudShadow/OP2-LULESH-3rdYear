//
// auto-generated by op2.py
//

void CalcMonotonicQRegionForElem_omp4_kernel(
  double *data0,
  int dat0size,
  int *map1,
  int map1size,
  int *map2,
  int map2size,
  double *data3,
  int dat3size,
  int *map4,
  int map4size,
  int *map5,
  int map5size,
  double *data6,
  int dat6size,
  int *map7,
  int map7size,
  int *map8,
  int map8size,
  double *data9,
  int dat9size,
  double *data10,
  int dat10size,
  double *data11,
  int dat11size,
  int *data12,
  int dat12size,
  double *data13,
  int dat13size,
  double *data14,
  int dat14size,
  double *data15,
  int dat15size,
  double *data16,
  int dat16size,
  double *data17,
  int dat17size,
  double *data18,
  int dat18size,
  double *data1,
  int dat1size,
  double *data2,
  int dat2size,
  double *data4,
  int dat4size,
  double *data5,
  int dat5size,
  double *data7,
  int dat7size,
  double *data8,
  int dat8size,
  int *col_reord,
  int set_size1,
  int start,
  int end,
  int num_teams,
  int nthread){

  #pragma omp target teams num_teams(num_teams) thread_limit(nthread) map(to:data0[0:dat0size],data3[0:dat3size],data6[0:dat6size],data9[0:dat9size],data10[0:dat10size],data11[0:dat11size],data12[0:dat12size],data13[0:dat13size],data14[0:dat14size],data15[0:dat15size],data16[0:dat16size],data17[0:dat17size],data18[0:dat18size]) \
    map(to: m_monoq_max_slope_ompkernel, m_monoq_limiter_mult_ompkernel, m_qlc_monoq_ompkernel, m_qqc_monoq_ompkernel, m_ptiny_ompkernel)\
    map(to:col_reord[0:set_size1],map1[0:map1size],map2[0:map2size],map4[0:map4size],map5[0:map5size],map7[0:map7size],map8[0:map8size],data1[0:dat1size],data2[0:dat2size],data4[0:dat4size],data5[0:dat5size],data7[0:dat7size],data8[0:dat8size])
  #pragma omp distribute parallel for schedule(static,1)
  for ( int e=start; e<end; e++ ){
    int n_op = col_reord[e];
    int map1idx;
    int map2idx;
    int map4idx;
    int map5idx;
    int map7idx;
    int map8idx;
    map1idx = map1[n_op + set_size1 * 0];
    map2idx = map2[n_op + set_size1 * 0];
    map4idx = map4[n_op + set_size1 * 0];
    map5idx = map5[n_op + set_size1 * 0];
    map7idx = map7[n_op + set_size1 * 0];
    map8idx = map8[n_op + set_size1 * 0];

    //variable mapping
    const double *delv_xi = &data0[1*n_op];
    const double *delv_xi_lxim = &data1[1 * map1idx];
    const double *delv_xi_lxip = &data2[1 * map2idx];
    const double *delv_eta = &data3[1*n_op];
    const double *delv_eta_letam = &data4[1 * map4idx];
    const double *delv_eta_letap = &data5[1 * map5idx];
    const double *delv_zeta = &data6[1*n_op];
    const double *delv_zeta_lzetam = &data7[1 * map7idx];
    const double *delv_zeta_lzetap = &data8[1 * map8idx];
    const double *delx_xi = &data9[1*n_op];
    const double *delx_eta = &data10[1*n_op];
    const double *delx_zeta = &data11[1*n_op];
    const int *elemBC = &data12[1*n_op];
    const double *m_vdov = &data13[1*n_op];
    double *qq = &data14[1*n_op];
    double *ql = &data15[1*n_op];
    const double *elemMass = &data16[1*n_op];
    const double *volo = &data17[1*n_op];
    const double *vnew = &data18[1*n_op];

    //inline function
    
      double qlin, qquad ;
      double phixi, phieta, phizeta ;
      double delvm = 0.0, delvp =0.0;
      int bcMask = elemBC[0] ;

      double norm = double(1.) / (delv_xi[0]+ m_ptiny_ompkernel ) ;

      switch (bcMask & XI_M) {
      case 0x00004:
      case 0:         delvm = delv_xi_lxim[0]; break ;
      case 0x00001: delvm = delv_xi[0] ;       break ;
      case 0x00002: delvm = double(0.0) ;      break ;
      default:
          delvm = 0;
          break;
      }
      switch (bcMask & 0x00038) {
      case 0x00020:
      case 0:         delvp = delv_xi_lxip[0] ; break ;
      case 0x00008: delvp = delv_xi[0] ;       break ;
      case 0x00010: delvp = double(0.0) ;      break ;
      default:
          delvp = 0;
          break;
      }

      delvm = delvm * norm ;
      delvp = delvp * norm ;

      phixi = double(.5) * ( delvm + delvp ) ;

      delvm *= m_monoq_limiter_mult_ompkernel ;
      delvp *= m_monoq_limiter_mult_ompkernel ;

      if ( delvm < phixi ) phixi = delvm ;
      if ( delvp < phixi ) phixi = delvp ;
      if ( phixi < double(0.)) phixi = double(0.) ;
      if ( phixi > m_monoq_max_slope_ompkernel) phixi = m_monoq_max_slope_ompkernel;

      norm = double(1.) / ( delv_eta[0] + m_ptiny_ompkernel ) ;

      switch (bcMask & 0x001c0) {
          case 0x00100:
          case 0:          delvm = delv_eta_letam[0] ; break ;
          case 0x00040: delvm = delv_eta[0] ;        break ;
          case 0x00080: delvm = double(0.0) ;        break ;
          default:
          delvm = 0;
          break;
      }
      switch (bcMask & 0x00e00) {
          case 0x00800:
          case 0:          delvp = delv_eta_letap[0] ; break ;
          case 0x00200: delvp = delv_eta[0] ;        break ;
          case 0x00400: delvp = double(0.0) ;        break ;
          default:
          delvp = 0;
          break;
      }

      delvm = delvm * norm ;
      delvp = delvp * norm ;

      phieta = double(.5) * ( delvm + delvp ) ;

      delvm *= m_monoq_limiter_mult_ompkernel ;
      delvp *= m_monoq_limiter_mult_ompkernel ;

      if ( delvm  < phieta ) phieta = delvm ;
      if ( delvp  < phieta ) phieta = delvp ;
      if ( phieta < double(0.)) phieta = double(0.) ;
      if ( phieta > m_monoq_max_slope_ompkernel)  phieta = m_monoq_max_slope_ompkernel;


      norm = double(1.) / ( delv_zeta[0] + m_ptiny_ompkernel ) ;

      switch (bcMask & 0x07000) {
          case 0x04000:
          case 0:           delvm = delv_zeta_lzetam[0] ; break ;
          case 0x01000: delvm = delv_zeta[0] ;         break ;
          case 0x02000: delvm = double(0.0) ;          break ;
          default:
          delvm = 0;
          break;
      }
      switch (bcMask & 0x38000) {
          case 0x20000:
          case 0:           delvp = delv_zeta_lzetap[0] ; break ;
          case 0x08000: delvp = delv_zeta[0] ;         break ;
          case 0x10000: delvp = double(0.0) ;          break ;
          default:
          delvp = 0;
          break;
      }

      delvm = delvm * norm ;
      delvp = delvp * norm ;

      phizeta = double(.5) * ( delvm + delvp ) ;

      delvm *= m_monoq_limiter_mult_ompkernel ;
      delvp *= m_monoq_limiter_mult_ompkernel ;

      if ( delvm   < phizeta ) phizeta = delvm ;
      if ( delvp   < phizeta ) phizeta = delvp ;
      if ( phizeta < double(0.)) phizeta = double(0.);
      if ( phizeta > m_monoq_max_slope_ompkernel  ) phizeta = m_monoq_max_slope_ompkernel;

      if ( m_vdov[0] > double(0.) )  {
          qlin  = double(0.) ;
          qquad = double(0.) ;
      }
      else {
          double delvxxi   = delv_xi[0]   * delx_xi[0]   ;
          double delvxeta  = delv_eta[0]  * delx_eta[0]  ;
          double delvxzeta = delv_zeta[0] * delx_zeta[0] ;

          if ( delvxxi   > double(0.) ) delvxxi   = double(0.) ;
          if ( delvxeta  > double(0.) ) delvxeta  = double(0.) ;
          if ( delvxzeta > double(0.) ) delvxzeta = double(0.) ;

          double rho = elemMass[0] / (volo[0] * vnew[0]) ;

          qlin = -m_qlc_monoq_ompkernel * rho *
          (  delvxxi   * (double(1.) - phixi) +
              delvxeta  * (double(1.) - phieta) +
              delvxzeta * (double(1.) - phizeta)  ) ;

          qquad = m_qqc_monoq_ompkernel * rho *
          (  delvxxi*delvxxi     * (double(1.) - phixi*phixi) +
              delvxeta*delvxeta   * (double(1.) - phieta*phieta) +
              delvxzeta*delvxzeta * (double(1.) - phizeta*phizeta)  ) ;
      }

      qq[0] = qquad ;
      ql[0] = qlin  ;
    //end inline func
  }

}
